# A class that represents planes, particularly as used as the bounds of convex polyhedra.
# Planes are defined by equations of the form Ax + By + Cz = D, which implicitly provides
# a normal to the plane, namely vector (A,B,C). The side of the plane that this vector
# points towards is considered the "outer" side of the plane, but there is no requirement
# that the normal be any particular length (other than that it not be 0). Because these
# planes are expected to bound convex polyhedra, planes also know about their neighbor
# planes relative to the polyhedron they bound, i.e., the planes with which they share
# an edge of the polyhedron. When planes list these neighbors, the lists are in some
# counterclockwise order as seen from the outer side of the plane.

# Copyright (C) 2019 by Doug Baldwin (baldwin@geneseo.edu).
# This work is licensed under a Creative Commons Attribution 4.0 International License
# (http://creativecommons.org/licenses/by/4.0/).

# History:
#
#   June 2019. Created by Doug Baldwin to support a program that builds single-layer
#     crystal aggregates.


from VectorOps import matrixMultiply, dot3
from math import sqrt




class Plane :
	
	
	
	
	# I describe planes by the following attributes:
	#   A, B, C, D - The coefficients of the plane's equation, Ax + By + Cz = D.
	#   neighbors - A list of planes which neighbor this one, i.e., share an edge with it
	#     in the polyhedron it encloses. This list lists the neighbors in counterclockwise
	#     order as seen from outside the plane.
	#    frozen - A Boolean value indicating whether this plane is "frozen" (if true) or
	#      not (if false). A frozen plane cannot move in order to expand its polyhedron.
	
	
	
	
	# Initialize a plane with the coefficients of its equation.
	
	def __init__( self, A, B, C, D ) :
		
		self.A = A
		self.B = B
		self.C = C
		self.D = D
		
		self.neighbors = []
		
		self.frozen = False
	
	
	
	
	# Tell a plane about some of its neighbor planes. The neighbors must be listed in
	# counterclockwise order as seen from outside this plane, and must all be
	# counterclockwise of any already-known neighbors. This method modifies the plane
	# that runs it, but has no explicit return value.
	
	def addNeighbors( self, neighbors ) :
		
		
		# Just append the new neighbors to any already known, since everything is in the
		# proper order for doing that.
		
		self.neighbors += neighbors
	
	
	
	
	# Return a list of a plane's neighbors.
	
	def getNeighbors( self ) :
		return self.neighbors
	
	
	
	
	# Determine whether a plane is frozen or not, returning True if it is and False
	# otherwise.
	
	def isFrozen( self ) :
		return self.frozen
	
	
	
	
	# Freeze or thaw a plane, according to whether the argument is True (to freeze) or
	# False. This method modifies the plane, but has no explicit return value.
	
	def makeFrozen( self, isFrozen ) :
		self.frozen = isFrozen
	
	
	
	
	# Determine whether a point is "inside" (or on) a plane. The "inside" of a plane is
	# the side its normal points away from (the "anti-normal" side). This method returns
	# True if the point is on or inside the plane, and False if not. I represent the point
	# as a list containing the point's x, y, and z coordinates.
	
	def pointOnOrInside( self, point ) :
		
		
		# The point is "inside" the plane if the point's dot product with the plane's
		# normal is less than the plane's D value; the point is on the plane if the dot
		# product and the D value are equal.
		
		return dot3( point, [ self.A, self.B, self.C ] ) <= self.D
	
	
	
	
	# Apply a linear transformation to this plane. In particular, return a new plane
	# generated by applying a change of basis to all points in this one and then
	# translating the result. Most commonly, this transformation represents a change of
	# coordinate frame, i.e., the new plane is this one expressed relative to a new frame.
	# This method receives as arguments the transpose of the inverse of the change of
	# basis matrix (a 3-by-3 matrix), and the translation vector (of length 3) in the
	# target coordinate system.
	
	def transform( self, matrix, translation ) :
		
		
		# The normal to the new plane is the inverse transpose of the change of basis
		# times the original normal. Represent that new normal as a list of coefficients
		# (i.e., a vector), although the matrix multiplication will yield it as a 1-column
		# matrix.
		
		newNormal = [ row[0] for row in matrixMultiply( matrix, [[self.A],[self.B],[self.C]] ) ]
		
		
		# The D term in the new plane's equation is the original D, plus the projection
		# of the translation vector in the direction of the new normal.
		
		newD = self.D + dot3( newNormal, translation )
		
		
		# Build the new plane.
		
		return Plane( newNormal[0], newNormal[1], newNormal[2], newD )
	
	
	
	
	# Cause a plane to move "dr" units away from the origin ("grow"), if it is free to do
	# so ("unfrozen"). This changes the plane, but has no explicit return value.
	
	def grow( self, dr ) :
		
		if not self.frozen :
			
			# Note that the mathematics of plane equations is such that in order for "dr"
			# to be a distance the plane moves, what I actually add to the "D" coefficient
			# has to be bigger than "dr" by a factor of the length of the plane's normal.
			
			self.D += dr * sqrt( self.A**2 + self.B**2 + self.C**2 )
	
	
	
	
	# Return a list of a plane's coefficients, in the order [A,B,C,D]. Note that this
	# order allows the coefficients to represent the plane's equation, Ax + By + Cz = D,
	# for linear system utility functions.
	
	def coefficients( self ) :
		return [ self.A, self.B, self.C, self.D ]
